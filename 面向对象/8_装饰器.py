'''装饰'''

# 装饰器（decorator）是一种特殊的函数，它可以用来修改其他函数的行为。
# 装饰器本质上是一个闭包，它可以将被装饰的函数作为参数，并返回一个新的函数，
# 新的函数可以包装原始函数，从而实现对原始函数行为的修改或增强。

# 装饰器的作用主要有以下几个方面：
# 实现代码的复用：
# 使用装饰器可以将一些通用的功能封装起来，然后在多个函数中重复使用。
# 例如，可以使用装饰器实现日志记录、性能统计、输入验证等功能，从而减少代码的冗余和复杂度。
# 动态修改函数行为：
# 使用装饰器可以在运行时动态地修改函数的行为，例如增加函数的功能、增加函数的参数等。
# 装饰器的这种特性使得它在框架和库的开发中得到广泛的应用。
# 实现 AOP 编程：
# 装饰器可以实现面向切面编程（AOP）的思想，即将通用的横切关注点（如日志记录、异常处理等）
# 从业务逻辑中分离出来，然后在需要的地方动态地将它们注入到函数中。
# 代码更加简洁：
# 使用装饰器可以使代码更加简洁，从而提高代码的可读性和可维护性。
# 例如，使用装饰器可以避免使用大量的 if/else 语句或 try/except 语句，从而让代码更加清晰和易于理解。
# 总之，装饰器是 Python 中非常强大和灵活的工具，可以用来解决很多常见的编程问题，同时也可以提高代码的复用性、可维护性和可读性。

# Python 中有很多装饰器，它们可以用于不同的场景，比如：
# @property: 用于将一个方法封装为属性，使其可以像访问实例变量一样来访问。
# @staticmethod: 用于将一个方法封装为静态方法，使其不需要访问实例变量。
# @classmethod: 用于将一个方法封装为类方法，使其可以访问类变量。
# @abstractmethod: 用于定义抽象方法，使其必须在子类中被实现。
# @final: 用于将一个方法或属性封装为最终版本，使其不可被重写或修改。
# @asyncio.coroutine: 用于将一个方法封装为协程，使其可以使用 async/await 语法来调用。
# @contextmanager: 用于定义上下文管理器，使其可以使用 with 语句来管理资源。
# @wraps: 用于将一个函数的元信息（如名称、文档字符串、参数列表等）复制到一个装饰器函数中。

